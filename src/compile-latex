#!/usr/bin/perl

if (0) {

=pod

=head1 NAME

compile-latex - compile TeX files as many times as needed

=head1 SYNOPSIS

compile-latex [I<options>] file[.tex]

compile-latex B<--depends>|B<--outputs>|B<--internals> file[.tex]

compile-latex [B<--makefile-prefix> I<prefix>] B<--makefile> I<makefile> file[.tex]

compile-latex B<--help>|B<--man>|B<--nroff>|B<--usage>

=cut

}

use strict;
use warnings;
use File::Spec;
use File::Basename;
use File::Find;
use File::Temp qw(tempdir);
use File::Path qw(make_path);
use Cwd qw(realpath);
use IPC::Open3;
use POSIX ":sys_wait_h";
use Sys::Hostname;
use Digest::MD5;
use Data::Dumper;
use Clone qw(clone);

# Global variables that reflect options that will by definition
# be the same for all files in one run.

my $help=0;                     # help mode
my $deps=0;                     # dependencies output
my $inBetween=' ';              # Separator for deps outputs
my $debug=1;                    # Verbosity
my $makefilemode='';            # Makefile name
my $makefileprefix='';          # in-Makefile common prefix
my %deplist=();

my $defaultenv={
                'inputfiles'       =>[],
                'jobname'          =>[],
               };

# launch

&init(@ARGV);
exit 0;                         # Anyway.

sub init {
  my $CLIenv=clone($defaultenv);
  $CLIenv->{'load'}=3;
  &parseARGV(1,$CLIenv,@_);
  if ($help) {
    &usage($help);
  }
  if ($#{$CLIenv->{'inputfiles'}} == -1) {
    print STDERR "No file specified\n";
    &usage($CLIenv->{'usage'});
  }
  # this may be deleted to support several inputfiles
  if ($#{$CLIenv->{'inputfiles'}} > 0) {
    print STDERR "Multiple files specified: ".join(' ',@{$CLIenv->{'inputfiles'}})."\n";
    &usage($CLIenv->{'usage'});
  }
  foreach my $filename (@{$CLIenv->{inputfiles}}) {
    $filename.='.tex' unless $filename =~ /\.tex$/;
    if (!existFile($filename)) {
      $filename =~ s/\.tex$// if /\.tex$/;
    }
    if (existFile($filename)) {
      &initInputFile($CLIenv,$filename);
    } else {
      die "Neither $filename.tex nor $filename are readable!";
    }
  }
  if ($deps) {
    print join($inBetween,sort keys %deplist),"\n";
  }
}

sub initInputFile {
  my $CLIenv=shift @_;
  my $inputfile=shift @_;
  my $INPUTenv=clone($defaultenv);
  &xlog(6,"▲ Searching $inputfile for options\n");
  open FILE,''.$inputfile;
  my @infile=();
  while (<FILE>) {
    chomp;
    next unless /^%+\s*compile-latex\s+option\s*:(.*$)/;
    push @infile,$1;
  }
  close FILE;
  if ($#infile != -1) {
    &parseARGV(0,$INPUTenv,@infile);
  }
  my $stem=basename($inputfile,'.tex');
  $CLIenv->{'naturalstem'}=$stem;
  my $jobnames;
  if ($#{$CLIenv->{'jobname'}} > -1) {
    $jobnames=$CLIenv->{'jobname'};
  } elsif ($#{$INPUTenv->{'jobname'}} > -1) {
    $jobnames=$INPUTenv->{'jobname'};
  } else {
    $jobnames=[$stem];
  }
  foreach $stem (@$jobnames) {
    initStemFile($CLIenv,$INPUTenv,$inputfile,$stem);
  }
}

sub initStemFile {
  my $CLIenv=shift @_;
  my $INPUTenv=shift @_;
  my $inputfile=shift @_;
  my $stem=shift @_;
  my $hashfile="$stem.md5";
  &xlog(2,"▲ Processing $stem out of $inputfile\n");
  my $hashenv=clone($defaultenv);
  $hashenv->{'cruftin'}={};
  $hashenv->{'cruftout'}={};
  $hashenv->{'oldin'}={};
  $hashenv->{'oldout'}={};
  $hashenv->{'in'}={};
  $hashenv->{'out'}={};
  $hashenv->{'hash'}={};
  $hashenv->{'pseudofile'}={};
  $hashenv->{'commands'}=[];
  $hashenv->{'stem'}=$stem;
  $hashenv->{'hashfile'}=$hashfile;
  $hashenv->{'input'}=$inputfile;
  my $loadedopts=&loadFiles($hashenv,$hashfile);
  if ($CLIenv->{'load'} & 0x2) {
    &parseARGV(1,$hashenv,@$loadedopts);
  }
  my $fullenv=mergeEnvironments($CLIenv,$hashenv);
  if ($CLIenv->{'load'} & 0x1) {
    $fullenv=mergeEnvironments($fullenv,$INPUTenv);
  }
  # include some default values
  $fullenv=mergeEnvironments($fullenv,{'auto'=>1});
  $fullenv->{'savedopts'}=[];
  &processIgnore($fullenv);
  &processBibOption($fullenv,1);
  &processIndexOption($fullenv);
  &loopCommands($fullenv);
  if ($deps & 0x1) {
    foreach (&outputDepends($fullenv)) {
      $deplist{$_}=1;
    }
  }
  if ($deps & 0x2) {
    foreach (&outputOutputs($fullenv)) {
      $deplist{$_}=1;
    }
  }
  if ($deps & 0x4) {
    foreach (&outputInternals($fullenv)) {
      $deplist{$_}=1;
    }
  }
  if ($makefilemode) {
    &outputMakefile($fullenv,$makefilemode,$makefileprefix);
  }
  if ($fullenv->{'ignore'} & 0x2) {
    &outputGitignore($fullenv);
  }
  if ($fullenv->{'ignore'} & 0x4) {
    &outputSvnignore($fullenv);
  }
}

sub parseARGV {
  my $_;
  my @args=();
  my $persist=shift @_;
  my $env=shift @_;
  my @savedopts=();
  my @lonearg=();
  my %shortopts=(
                 'j' => '--jobname',
                 'i' => '--index-file-suffix',
                 'o' => '--index-output-suffix',
                 'M' => '--make',
                 'I' => '--ignore',
                 'h' => '--help',
                 'l' => '--load-all',
                 'L' => '--load-none'
                );

=pod

=head1 OPTIONS

=head2 SHORT OPTIONS

A few short options are provided. They can be agregated (such as
C<-MI>), but only the last one may have a value.

=cut

  my @loneopts=('--help','--depends','--outputs','--make','--quiet',
                '--index','--man','--internals','--usage',
                '--nroff','--bibtex','--manual','--discover','--gitignore',
                '--load-all','--load-old','--load-input','--load-none',
                '--ignore','--svnignore','--noignore'
               );
  my @oneopts=('--separator','--index-file','--index-style','--index-output',
               '--index-file-suffix','--index-output-suffix','--index-options',
               '--input','--debug','--bibtex-file','--bibtex-file-suffix',
               '--makefile','--makefile-prefix','--jobname',
              );
  my $m;
 ARGS: while ($#_>-1) {
    $_=shift @_;
    if (/^-[a-zA-Z]+$/) {
      foreach $m (reverse 1..length($_)-1) {
        my $xk=substr($_,$m,1);
        if (!exists($shortopts{$xk})) {
          print STDERR "No file specified\n";
          &usage('usage');
        }
        unshift @_,$shortopts{$xk};
      }
      next ARGS;
    }
    foreach $m (@loneopts) {
      if (/^$m$/) {
        push @args,[$_];
        next ARGS;
      }
    }
    foreach $m (@oneopts) {
      if (/^$m$/) {
        push @args,[$_,$_[0]] if (/^$m$/);
        shift @_;
        next ARGS;
      }
    }
    push @lonearg,$_;
  }
  push $env->{'inputfiles'},@lonearg;
  my $index='suffix://idx';
  foreach (@args) {
    my $arg=${$_}[0];
    my $val=${$_}[1];
    if ($arg eq '--quiet') {
      $debug=0;

=pod

=head2 GENERIC OPTIONS

B<--jobname>|B<-j> Use this jobname. Can be repeated to loop through several
jobnames. I<Not persistent>.

B<--debug> I<n> Change the verbosity level to I<n> (see
L</"DEBUG">). I<Not persistent>.

B<--quiet> Same as C<--debug 0>.

B<--manual> Removes automatic mode.

B<--discover> (default) Automatic discovery mode. Currently, finds all
bibtex-able files and add appropriate actions to deal with them. Also
adds the idx/ind index action (only if no other index option is given).

B<--load-all>|B<-l> Load options from command line, input file and hash file(s).

B<--load-old> Load options from command line and hash file(s).

B<--load-input> Load options from command line and input file.

B<--load-none>|B<-L> Load options from command line only.

=cut

    } elsif ($arg eq '--debug') {
      $debug=int($val);
    } elsif ($arg eq '--manual') {
      $env->{'auto'}=0;
    } elsif ($arg eq '--discover') {
      $env->{'auto'}=1;
    } elsif ($arg eq '--load-all') {
      $env->{'load'}=3;
    } elsif ($arg eq '--load-none') {
      $env->{'load'}=0;
    } elsif ($arg eq '--load-input') {
      $env->{'load'}=1;
    } elsif ($arg eq '--load-old') {
      $env->{'load'}=2;
    } elsif ($arg eq '--jobname') {
      push $env->{'jobname'},$val;
    } elsif ($arg eq '--bibtex') {
      $env->{'bibFile'}->{'suffix://aux'}=1;

=pod

=head2 BIBTEX OPTIONS

B<--bibtex-file> I<somefile> Marks some file to be an input for
C<bibtex>. Can be given multiple times. Discovery mode will probably
spot all bibtex-able files anyway, so mostly useful in manual
mode. Persistent.

B<--bibtex-file-suffix> I<string> Same as above, except it uses
C<jobname.string>.

B<--bibtex> Equivalent to B<--bibtex-file> I<file.aux>.

=cut

    } elsif ($arg eq '--bibtex-file-suffix') {
      $env->{'bibFile'}->{'suffix://'.$val}=1;
    } elsif ($arg eq '--bibtex-file') {
      $env->{'bibFile'}->{$val}=1;
    } elsif ($arg eq '--index') {

=pod

=head2 INDEX OPTIONS

B<--index-file> I<somefile> Marks some file to be an input for
C<makeindex>. Can be given multiple times.

B<--index-file-suffix>|B<-i> I<extension> The same as above, but for the
file I<file>.I<extension>.

Each of the following option applies to the preceding C<index-file>:

B<--index-style> I<somefile> Corresponds to option B<-t> of makeindex.

B<--index-output> I<somefile> Corresponds to option B<-t> of makeindex.

B<--index-output-suffix>|B<-o> I<extension> The same as above, but for
the file I<file>.I<extension>.

B<--index-options> I<string> Corresponds to other options of makeindex,
separated by spaces, see L</"QUOTING">.

=cut

      $index='suffix://idx';
      $env->{'indexFile'}->{$index}->{'do'}=1;
    } elsif ($arg eq '--index-file-suffix') {
      $index='suffix://'.$val;
      $env->{'indexFile'}->{$index}->{'do'}=1;
    } elsif ($arg eq '--index-file') {
      $index=$val;
      $env->{'indexFile'}->{$index}->{'do'}=1;
    } elsif ($arg eq '--index-output-suffix') {
      $env->{'indexFile'}->{$index}->{'output'}='suffix://'.$val;
    } elsif ($arg eq '--index-output') {
      $env->{'indexFile'}->{$index}->{'output'}=$val;
    } elsif ($arg eq '--index-style-suffix') {
      $env->{'indexFile'}->{$index}->{'style'}='suffix://'.$val;
    } elsif ($arg eq '--index-style') {
      $env->{'indexFile'}->{$index}->{'style'}=$val;
    } elsif ($arg eq '--index-options') {
      $env->{'indexFile'}->{$index}->{'options'}=[map {&unquote($_)} split(/ /,$val)];
    } elsif ($arg eq '--depends') {
      $debug=0;
      $deps=$deps|0x1;

=pod

=head2 DEPENDENCY OPTIONS

All of these options are not persistent.

B<--depends> List local files read by compilation and not overwritten
(C<.tex>, C<.cls>,...)

B<--internals> List local files both output and read by compilation
(C<.aux>...)

B<--outputs> List local files output by compilation, but not read
(C<.log>...).

B<--makefile> I<file.mk> Outputs a makefile snippet included in
I<file.mk>. The sections are self-delimited and replaced if already
present (see  L</"MAKEFILE">).

B<--make>|B<-m> Same as C<--makefile Makefile>.

B<--makefile-prefix> Prepend a common prefix to all phony targets of the
makefile generated by the B<--makefile> option.

B<--separator> I<string> Use this quoted string as separator between
names instead of one space (see L</"QUOTING">).

B<--ignore>|B<-I> Autoignore mode. Select first CVS and use it.

B<--gitignore> Edit C<./.gitignore> to ignore output and internals files.

B<--svnignore> Edit property C<svn:ignore> to ignore output and internals files.

B<--noignore> No ignore generation.

=cut

    } elsif ($arg eq '--outputs') {
      $debug=0;
      $deps=$deps|0x2;
    } elsif ($arg eq '--internals') {
      $debug=0;
      $deps=$deps|0x4;
    } elsif ($arg eq '--ignore') {
      $env->{'ignore'}=0 if (!exists($env->{'ignore'}));
      $env->{'ignore'}=$env->{'ignore'}|0x1;
    } elsif ($arg eq '--gitignore') {
      $env->{'ignore'}=0 if (!exists($env->{'ignore'}));
      $env->{'ignore'}=$env->{'ignore'}|0x2;
    } elsif ($arg eq '--svnignore') {
      $env->{'ignore'}=0 if (!exists($env->{'ignore'}));
      $env->{'ignore'}=$env->{'ignore'}|0x4;
    } elsif ($arg eq '--noignore') {
      $env->{'ignore'}=0;
    } elsif ($arg eq '--make') {
      $makefilemode='Makefile';
    } elsif ($arg eq '--makefile') {
      $makefilemode=$val;
    } elsif ($arg eq '--makefile-prefix') {
      $makefileprefix=$val;
    } elsif ($arg eq '--separator') {
      $inBetween=&unquote($val);
    } elsif ($arg eq '--help') {
      $help="help";

=pod

=head2 HELP OPTIONS

B<--help>|B<-h> Generate this help (long version).

B<--usage> Generate this help (short version).

B<--man> Generate man page.

B<--nroff> Generate man page in NROFF format.

=cut

    } elsif ($arg eq '--man') {
      $help="man";
    } elsif ($arg eq '--nroff') {
      $help="nroff";
    } elsif ($arg eq '--usage') {
      $help="usage";
    }
  }
  $env->{'savedopts'}=\@savedopts if ($persist and $#savedopts>-1);
}

sub suffixFile {
  my ($env,$k,$opt,$persist)=@_;
  my $stem=$env->{'stem'};
  my $kk=$k;
  $kk=~ s|^suffix://|$stem.|;
  if ($kk ne $k) {
    my $kkk=$k;
    $kkk=~ s|^suffix://||;
    push $env->{'savedopts'},$opt.'-suffix',$kkk if $persist;
  } else {
    push $env->{'savedopts'},$opt,$k if $persist;
  }
  return $kk;
}

sub processBibOption {
  my $env=shift @_;
  my $persist=shift @_;
  my $k;
  my $kk;
  my $cmdline;
  my $tagline;
  foreach $k (keys %{$env->{'bibFile'}}) {
    $kk=&suffixFile($env,$k,'--bibtex-file',$persist);
    next if ($env->{'bibFileUniq'}->{$kk});
    $env->{'bibFileUniq'}->{$kk}=1;
    $cmdline=['bibtex',$kk];
    $tagline=join(' ',@$cmdline);
    push $env->{'commands'},
      {'proc' => \&pseudofileBib,
       'args' => {'input'=>$kk,'autobib'=>2}
      };
    push $env->{'commands'},
      {'proc' => \&genericRunner,
       'args' => {'input'=>'pseudo://bib/'.$kk,
                  'tagline'=>$tagline,
                  'cmdline'=>$cmdline,
                  'autobib'=>1}
      };
  }
}

sub processIndexOption {
  my $env=shift @_;
  my $persist=1;
  my $k;
  my $kk;
  my $kkk;
  my $cmdline;
  my $tagline;
  my @set=(keys %{$env->{'indexFile'}});
  if ($#set<0 and $env->{'auto'}) {
    $persist=0;
    $env->{'indexFile'}->{'suffix://idx'}->{'do'}=1;
    @set=(keys %{$env->{'indexFile'}});
  }
  foreach $k (@set) {
    my $e=$env->{'indexFile'}->{$k};
    $kkk=&suffixFile($env,$k,'--index-file',$persist);
    $cmdline=['makeindex'];
    push $cmdline,'-o',
      &suffixFile($env,$e->{'output'},
                  '--index-output',$persist) if (exists($e->{'output'}));
    push $cmdline,'-s',
      &suffixFile($env,$e->{'style'},
                  '--index-style',$persist) if (exists($e->{'style'}));
    push $cmdline,@{$e->{'options'}} if (exists($e->{'options'}));
    if ($persist && $#{$e->{'options'}}>-1) {
      push $env->{'savedopts'},'--index-options',join(' ',map {&quote($_)} @{$e->{'options'}});
    }
    push $cmdline,$kkk;
    $tagline=join(' ',@$cmdline);
    push $env->{'commands'},
      {'proc' => \&genericRunner,
       'args' => {'input'=>$kkk,
                  'tagline'=>$tagline,
                  'cmdline'=>$cmdline
                 }
      };
  }
}

sub processIgnore {
  my $env=shift @_;
  if (!exists($env->{'ignore'})) {
    $env->{'ignore'}=0;
  }
  return unless ($env->{'ignore'} & 0x1);
  my $path=&realpath($env->{'stem'});
  my $top=0;
  my $found=0;
  while (!$top && !$found) {
    $path=&dirname($path);
    $top=1 if ($path =~ m|^/$|);
    if (-d File::Spec->catdir($path,'.git')) {
      $env->{'ignore'}=$env->{'ignore'}|0x2;
      $found=1;
    }
    if (-d File::Spec->catdir($path,'.svn')) {
      $env->{'ignore'}=$env->{'ignore'}|0x4;
      $found=1;
    }
  }
  return;
}

sub pseudofileBib {
  my $_;
  my ($env,$arg,$tmpdir)=@_;
  my $out=$env->{'out'};
  my $in=$env->{'in'};
  my $hash=$env->{'hash'};
  my $inputfile=$arg->{'input'};
  my $outputfile='pseudo://bib/'.$inputfile;
  my $key="pseudofileBib ".&quote($inputfile);
  my $tagline="Extracting bibliography from $inputfile";
  &forceDependency($env,$key,$inputfile);
  my @changed=&preMortem($env,$key);
  if ($#changed==-1) {
    # Necessary only for debug
    &xlog(3,"▲ $tagline...done\n");
    &postVitam($env,$key);
    return 1;
  } elsif ($#changed < 5) {
    &xlog(2,'Changed: ',join(' ',@changed),'');
  } else {
    &xlog(2,'Changed: ',$#changed,' files','');
    &xlog(6,'Changed: ',join(' ',@changed),'');
  }
  &xlog(2,"△ $tagline...");
  open FILE,$inputfile;
  my $data='';
  while (<FILE>) {
    next unless (/^\\bibstyle/ or /^\\bibdata/ or /^\\citation/);
    $data.=$_;
  }
  close FILE;
  &xlog(2,"ok\n");
  $out->{$key}={};
  $in->{$key}={};
  $out->{$key}->{$outputfile}="1";
  $in->{$key}->{$inputfile}="1";
  if ($data eq '') {
    delete $env->{'pseudofile'}->{$outputfile};
  } else {
    $env->{'pseudofile'}->{$outputfile}=$data;
  }
  foreach (keys %{$out->{$key}}) {
    if (!exists($hash->{$_})) {
      $hash->{$_}="?";
    }
  }
  foreach (keys %{$in->{$key}}) {
    if (!exists($hash->{$_})) {
      &hashFile($_,$env);
    }
    $in->{$key}->{$_}=$hash->{$_};
  }
  return 0;
}

sub loopCommands {
  my $env=shift @_;
  my $stem=$env->{'stem'};
  if (!exists($env->{'auto'}) || $env->{'auto'}) {
    unshift $env->{'commands'},
      {
       'proc' => \&autoDiscovery,
       'args' => {'autodiscovery'=>1}
      };
    push $env->{'savedopts'},'--discover';
  } else {
    push $env->{'savedopts'},'--manual';
  }
  unshift $env->{'commands'},{'proc' => \&latexFile,'args' => {}};
  unshift $env->{'commands'},{'proc' => \&newRound,'args' => {}};
  push $env->{'commands'},{'proc' => \&storeCruft,'args' => {},'keepatend'=>1};
  push $env->{'commands'},{'proc' => \&storeFiles,'args' => {},'keepatend'=>1};
  # Heuristic: anticipating the input files
  opendir (my $dh,'.') || die "Could not open current directory: $!";
  while (readdir($dh)) {
    next unless /^${stem}\./;
    hashFile($_,$env);
  }
  closedir($dh);
  my $commandindex=-1;
  my $commandredo=1;
  my $tmpdir=tempdir(CLEANUP => 1);
  while ($commandredo) {
    my $i=-1;
    $commandredo=0;
    while ($i < $#{$env->{'commands'}}) { # not a foreach, because the list can change
      $i++;
      my $comm=$env->{'commands'}[$i];
      my $func=$comm->{'proc'};
      my $ret=&$func($env,$comm->{'args'},$tmpdir);
      $commandredo=1 unless ($ret);
    }
  }
}

sub loadFiles {
  my ($env)=@_;
  my @loadedopts;
  &xlog(3,"▲ Loading hashes\n");
  open FILE,$env->{'hashfile'} or return;
  while (<FILE>) {
    chomp;
    next unless /^([a-z]+);([^;]*);([^;]*);(.*)$/;
    my ($t,$p,$v,$f)=($1,$2,$3,$4);
    if ($t eq 'in') {
      $env->{'in'}->{$p}={} unless (exists($env->{'in'}->{$p}));
      $env->{'in'}->{$p}->{$f}=$v;
    }
    if ($t eq 'mainkey') {
      $env->{'mainkey'}=&unquote($p);
    }
    if ($t eq 'out') {
      $env->{'out'}->{$p}={} unless (exists($env->{'out'}->{$p}));
      $env->{'out'}->{$p}->{$f}=$v;
    }
    if ($t eq 'option') {
      push @loadedopts,&unquote($p);
    }
    if ($t eq 'pseudofile') {
      $env->{'pseudofile'}->{&unquote($v)}=&unquote($p);
    }
    if ($t eq 'mainkey') {
      $env->{'mainkey'}=&unquote($p);
    }
    if ($t eq 'outputfile') {
      $env->{'outputFile'}=&unquote($p);
    }
    if ($t eq 'cruftin') {
      $env->{'cruftin'}->{$p}=1;
    }
    if ($t eq 'cruftout') {
      $env->{'cruftout'}->{$p}=1;
    }
  }
  close FILE;
  return \@loadedopts;
}

sub newRound {
  my $env=shift @_;
  $env->{'round'}++;
  &xlog(2,"▲ Round ".$env->{'round'}."\n");
  $env->{'oldin'}=$env->{'in'};
  $env->{'oldout'}=$env->{'out'};
  $env->{'in'}={};
  $env->{'out'}={};
  return 1;
}

sub autoDiscovery {
  my $env=shift @_;
  return 1 if ($env->{'round'} > 1);
  my $tagline=("Auto-discovery");
  &xlog(2,"▲ $tagline...");
  &xlog(2,"ok\n");
  foreach my $file (keys %{$env->{'out'}->{$env->{'mainkey'}}}) {
    next unless existFile($file);
    my $bib=1;
    goto REGISTER if ($file eq $env->{'stem'}.'.aux');
    $bib=0;
    open FILE,$file;
    while (<FILE>) {
      if (/^\\bibstyle/ or /^\\bibcite/ or /^\\bibdata/ or /^\\citation/) {
        $bib=1;last;
      } else {
        $bib=0;last;
      }
    }
    close FILE;
  REGISTER:
    if ($bib) {
      &xlog(2,"Spotted...$file",'');
      # KLUDGE TODO: check attributes instead of "always two"
      my $a=pop $env->{'commands'};
      my $b=pop $env->{'commands'};
      $env->{'bibFile'}->{$file}=1;
      processBibOption($env,0);
      push $env->{'commands'},$b,$a;
    }
  }
  return 1;
}

sub latexFile {
  my ($env,$arg,$tmpdir)=@_;
  my $tmpfile=File::Spec->catfile($tmpdir,"trace");
  my @cmdline=('pdflatex','-interaction','batchmode','-halt-on-error',
               '--jobname',$env->{'stem'},
               $env->{'input'});
  my $tagline;
  if ($env->{'stem'} ne $env->{'naturalstem'}) {
    $tagline=('pdflatex --jobname '.$env->{'stem'}.' '.$env->{'input'});
  } else {
    $tagline=('pdflatex '.$env->{'input'});
  }
  $env->{'outputFile'}=$env->{'stem'}.'.pdf';
  my $key=&commandKey(@cmdline);
  my $mainkey=$key;
  $env->{'mainkey'}=$key;
  &forceDependency($env,$key,$env->{'input'});
  my @changed=&preMortem($env,$key);
  if ($#changed==-1) {
    # Necessary only for debug
    &xlog(3,"▲ $tagline...done\n");
    &postVitam($env,$key);
    return 1;
  } elsif ($#changed < 5) {
    &xlog(2,'Changed: ',join(' ',@changed),'');
  } else {
    &xlog(2,'Changed: ',$#changed,' files','');
    &xlog(6,'Changed: ',join(' ',@changed),'');
  }
  &xlog(1,"△ $tagline...");
  $a=executeCommand('',
                    'strace','-f','-e','trace=access,open',
                    '-o',$tmpfile,
                    @cmdline
                   );
  if ($a->[0] == 0) {
    &xlog(1,"ok\n");
  } else {
    &xlog(1,"fail\n");
    &storeFiles;
    die "Argh";
  }
  &postMortem($env,$key,$tmpfile);
  return 0;
}

sub genericRunner {
  my ($env,$arg,$tmpdir)=@_;
  my $input=$arg->{'input'};
  my $tmpfile=File::Spec->catfile($tmpdir,"trace");
  my @cmdline=@{$arg->{'cmdline'}};
  my $tagline=$arg->{'tagline'};
  my $key=&commandKey(@cmdline);
  &forceDependency($env,$key,$input);
  my @changed=&preMortem($env,$key);
  if ($#changed==-1 || ($env->{'hash'}->{$input} eq "0")) {
    # Necessary only for debug
    &xlog(3,"▲ $tagline...done\n");
    &postVitam($env,$key);
    return 1;
  } elsif ($#changed < 5) {
    &xlog(2,'Changed: ',join(' ',@changed),'');
  } else {
    &xlog(2,'Changed: ',$#changed,' files','');
    &xlog(6,'Changed: ',join(' ',@changed),'');
  }
  &xlog(1,"△ $tagline...");
  $a=executeCommand('',
                    'strace','-f','-e','trace=access,open',
                    '-o',$tmpfile,
                    @cmdline
                   );
  if ($a->[0] == 0) {
    &xlog(1,"ok\n");
  } else {
    &xlog(1,"fail\n");
    die "Argh";
  }
  &postMortem($env,$key,$tmpfile);
  # in some cases, the "inputfile" is not read
  $env->{'in'}->{$key}->{$input}=$env->{'hash'}->{$input} if ($input =~ /^pseudo:\/\//);
  return 0;
}

sub storeCruft {
  &xlog(2,"▲ Collecting modified files\n");
  my $env=shift @_;
  my $out=$env->{'out'};
  my $in=$env->{'in'};
  $out->{'storeFiles'}={$env->{'hashfile'}=>1};
  foreach my $prog (sort keys %$out) {
    foreach (sort keys %{$out->{$prog}}) {
      next if /^pseudo:\/\//;
      $env->{'cruftout'}->{$_}=1;
    }
  }
  foreach my $prog (sort keys %$in) {
    foreach (sort keys %{$in->{$prog}}) {
      next if /^pseudo:\/\//;
      next unless &existFile($_);
      $env->{'cruftin'}->{$_}=1;
    }
  }
  return 1;
}

sub storeFiles {
  &xlog(2,"▲ Storing hashes\n");
  my $env=shift @_;
  my $out=$env->{'out'};
  my $in=$env->{'in'};
  my $v;
  my $spec=0;
  open FILE,'>'.$env->{'hashfile'};
  foreach my $prog (sort keys %$in) {
    foreach my $key (sort keys %{$in->{$prog}}) {
      $v=$in->{$prog}->{$key};
      print FILE "in;$prog;$v;$key\n";
    }
  }
  foreach my $prog (sort keys %$out) {
    foreach my $key (sort keys %{$out->{$prog}}) {
      $v=$out->{$prog}->{$key};
      print FILE "out;$prog;$v;$key\n";
    }
  }
  foreach my $opt (@{$env->{'savedopts'}}) {
    if ($opt eq "--index-options") {
      $spec=1;
      print FILE "option;",&quote($opt),";1;\n";
    } elsif ($spec == 1) {
      $spec=0;
      print FILE "option;",$opt,";1;\n";
    } else {
      print FILE "option;",&quote($opt),";1;\n";
    }
  }
  foreach my $opt (keys %{$env->{'pseudofile'}}) {
    print FILE "pseudofile;",&quote($env->{'pseudofile'}->{$opt}),';',&quote($opt),";\n";
  }
  foreach my $opt (keys %{$env->{'cruftin'}}) {
    print FILE "cruftin;",&quote($opt),";;\n";
  }
  foreach my $opt (keys %{$env->{'cruftout'}}) {
    print FILE "cruftout;",&quote($opt),";;\n";
  }
  print FILE "mainkey;",&quote($env->{'mainkey'}),";;\n";
  print FILE "outputfile;",&quote($env->{'outputFile'}),";;\n";
  close FILE;
  return 1;
}

sub postVitam {
  my $_;
  my ($env,$key)=@_;
  $env->{'in'}->{$key}=clone($env->{'oldin'}->{$key});
  $env->{'out'}->{$key}=clone($env->{'oldout'}->{$key});
  foreach (keys %{$env->{'out'}->{$key}}) {
    if (!exists($env->{'hash'}->{$_})) {
      $env->{'hash'}->{$_}="?";
    }
  }
}

sub postMortem {
  my $_;
  my ($env,$key,$tmpfile)=@_;
  open TRACE,"$tmpfile";
  while (<TRACE>) {
    if (/^[0-9]+\s+access\("([^"]*)",.R_OK\)\s*=\s*[-0-9]*/) {
      my $file=$1;
      $file =~ s/^\.\///g;
      $env->{'in'}->{$key}->{$file}="1";
      next;
    }
    if (/^[0-9]+\s+open\("([^"]*)",.O_WRONLY.*\)\s*=\s*[-0-9]*$/) {
      my $file=$1;
      $file =~ s/^\.\///g;
      $env->{'out'}->{$key}->{$file}="1";
      next;
    }
  }
  close TRACE;
  unlink $tmpfile;
  # Update hash
  foreach (keys %{$env->{'out'}->{$key}}) {
    if (!exists($env->{'hash'}->{$_})) {
      $env->{'hash'}->{$_}="?";
    }
  }
  foreach (keys %{$env->{'in'}->{$key}}) {
    if (!exists($env->{'hash'}->{$_})) {
      &hashFile($_,$env);
    }
    $env->{'in'}->{$key}->{$_}=$env->{'hash'}->{$_};
  }
}

sub forceDependency {
  my ($env,$key,$file)=@_;
  if (!exists($env->{'oldin'}->{$key})) {
    $env->{'oldin'}->{$key}={};
  }
  return unless existFile($file);
  if (!exists($env->{'oldin'}->{$key}->{$file})) {
    $env->{'oldin'}->{$key}->{$file}="1";
  }
}

sub preMortem {
  my $_;
  my ($env,$key)=@_;
  my $oldin=$env->{'oldin'};
  my $oldout=$env->{'oldout'};
  my $hash=$env->{'hash'};
  my $changed=0;
  my @changed=();
  if (!exists($oldin->{$key})) {
    $oldin->{$key}={};
  }
  if (!exists($oldout->{$key})) {
    $oldout->{$key}={};
  }
  my @inkeys=keys %{$oldin->{$key}};
  my @outkeys=keys %{$oldout->{$key}};
  foreach (@inkeys) {
    &hashFile($_,$env);
    if ($hash->{$_} ne $oldin->{$key}->{$_}) {
      &xlog(5,"H: $_ ".$oldin->{$key}->{$_}."=>".$hash->{$_}."\n");
      push @changed,$_;
    }
  }
  foreach (@outkeys) {
    if (!existFile($_)) {
      push @changed,'miss:'.$_;
    }
  }
  return @changed;
}

sub usage {
  ### usage ($option)
  ### Provides all kinds of textual help and stops
  my ($option)=@_;
  if (!defined($option)) {
    $option="usage";
  }
  my $cmd="pod2txt";
  my $release="0.6.1";
  my ($a,$out,$b);
  if ($option eq "man"||$option eq "nroff") {
    ($a,$out,$b)=@{&executeCommand("","pod2man","$0","--center","User commands","--release",$release)};
    if ($a==0 && $option eq "man") {
      ($a,$out,$b)=@{&executeCommand($out,"nroff","-man","-")};
    }
  } else {
    ($a,$out,$b)=@{&executeCommand("","pod2text","$0")};
  }
  if ($option eq "usage") {
    $out =~ s/OPTIONS.*$//s;
  }
  if ($option ne "man") {
    print $out;
  } else {
    open FILE,"|pager";
    print FILE $out;
    close FILE;
  }
  exit;
}

sub outputDepends {
  my $env=shift @_;
  my %cruftin=%{$env->{'cruftin'}};
  my %cruftout=%{$env->{'cruftout'}};
  my %list=();
  foreach (sort keys %cruftin) {
    next if exists $cruftout{$_};
    next if /^\//;
    $list{$_}=1;
  }
  return keys %list;
}

sub outputOutputs {
  my $env=shift @_;
  my %cruftin=%{$env->{'cruftin'}};
  my %cruftout=%{$env->{'cruftout'}};
  my %list=();
  foreach (sort keys %cruftout) {
    next if exists $cruftin{$_};
    next if /^\//;
    $list{$_}=1;
  }
  return keys %list;
}

sub outputInternals {
  my $env=shift @_;
  my %cruftin=%{$env->{'cruftin'}};
  my %cruftout=%{$env->{'cruftout'}};
  my %list=();
  foreach (sort keys %cruftout) {
    next unless exists $cruftin{$_};
    next if /^\//;
    $list{$_}=1;
  }
  return keys %list;
}

sub outputSection {
  my ($file,$section,$data)=@_;
  my @lines=();
  my $inside=0;
  my $done=0;
  if (existFile($file)) {
    open FILE,$file;
    while (<FILE>) {
      if (/^# start automatic section for $section$/) {
        $inside=1;
        if (!$done) {
          $done=1;
          push @lines,"# start automatic section for $section\n";
          push @lines,$data;
          push @lines,"# stop automatic section for $section\n";
        }
        next;
      }
      if (/^# stop automatic section for $section$/) {
        $inside=0;next;
      }
      next if $inside==1;
      push @lines,$_;
    }
    if (!$done) {
      push @lines,"# start automatic section for $section\n";
      push @lines,$data;
      push @lines,"# stop automatic section for $section\n";
    }
    close FILE;
  } else {
    push @lines,"# start automatic section for $section\n";
    push @lines,$data;
    push @lines,"# stop automatic section for $section\n";
  }
  open FILE,">$file";
  foreach (@lines) {
    print FILE $_;
  }
  close FILE;
}

sub outputMakefile {
  my ($env,$file,$pref)=@_;
  my @savedopts=@{$env->{'savedopts'}};
  my $stem=$env->{'stem'};
  &outputSection($file,'//common',"COMPILELATEX ?= compile-latex\n".
                 "${pref}all::\n".
                 ".PHONY: ${pref}do ${pref}depends-as-is ${pref}depends ${pref}distclean ${pref}clean ${pref}all\n"
                );

  my $snip='';
  $snip.="${pref}all:: ".$env->{'outputFile'}."\n";
  $snip.="${pref}do::\n";
  $snip.="\t\$(COMPILELATEX) --load-none ".&makefileshellquote(' ','--jobname',$env->{'stem'},@savedopts,$env->{'input'})."\n";
  $snip.=&makefilequote(' ',&outputOutputs($env)).
    ":\\\n".&makefilequote("\\\n",&outputDepends($env))."\n";
  $snip.="\t\$(COMPILELATEX) --load-none ".&makefileshellquote(' ','--jobname',$env->{'stem'},@savedopts,$env->{'input'})."\n";
  $snip.="${pref}distclean::\n";
  my %list=();
  foreach (&outputInternals($env),&outputOutputs($env)) {
    $list{$_}++;
  }
  $snip.="\trm -f ".&makefileshellquote(' ',sort keys %list)."\n";
  $snip.="${pref}clean::\n";
  delete ($list{$env->{'outputFile'}});
  $snip.="\trm -f ".&makefileshellquote(' ',sort keys %list)."\n"; 
  $snip.="${pref}depends::\n";
  $snip.="\t\$(COMPILELATEX) --load-none ";
  $snip.=&savedIgnore($env);
  $snip.='--makefile-prefix '.&makefileshellquote(' ',$pref).' ' if ($pref);
  $snip.='--makefile '.&makefileshellquote(' ',$file,'--jobname',
                                           $env->{'stem'},
                                           $env->{'input'})."\n";
  $snip.="${pref}depends-as-is::\n";
  $snip.="\t\$(COMPILELATEX) ";
  $snip.=&savedIgnore($env);
  $snip.='--makefile-prefix '.&makefileshellquote(' ',$pref).' ' if ($pref);
  $snip.='--makefile '.&makefileshellquote(' ',$file,'--jobname',
                                           $env->{'stem'},
                                           $env->{'input'})."\n";
  &outputSection($file,$env->{'stem'},$snip);
}

sub outputGitignore {
  my ($env)=@_;
  my ($file,$snip)=('.gitignore','');
  my %list=();
  foreach (&outputInternals($env),&outputOutputs($env)) {
    $list{$_}++;
  }
  foreach (sort keys %list) {
    $snip.="/$_\n";
  }
  &outputSection($file,$env->{'stem'},$snip);
}
sub outputSvnignore {
  my ($env)=@_;
  print STDERR "Not implemented yet\n";
  return;
}
sub savedIgnore {
  my ($env)=@_;
  return '' if ($env->{'ignore'} == 0);
  return '--ignore ' if ($env->{'ignore'} & 0x1);
  my $i='';
  if ($env->{'ignore'} & 0x2) {
    $i.='--gitignore ';
  }
  if ($env->{'ignore'} & 0x4) {
    $i.='--svnignore ';
  }
}

sub unquote {
  my $d=shift @_;
  $d=~s/%3B/\n/g;
  $d=~s/%0A/\n/g;
  $d=~s/%20/ /g;
  $d=~s/%25/%/g;
  return $d;
}
sub quote {
  my $d=shift @_;
  $d=~s/%/%25/g;
  $d=~s/ /%20/g;
  $d=~s/;/%3B/g;
  $d=~s/\n/%0A/g;
  return $d;
}
sub makefileshellquote {
  my ($a,@x)=@_;
  foreach my $d (@x) {
    if ($d eq '') {
      $d="''";
    } elsif ($d =~ /[^-._a-zA-Z0-9]/) {
      $d=~s/'/'\\''/g;
      $d=~ s/\$/\$\$/g;
      $d="'".$d."'";
    }
  }
  return join($a,@x);
}
sub makefilequote {
  my ($a,@x)=@_;
  foreach my $d (@x) {
    $d =~ s/ /\\\\/g;
  }
  return join($a,@x);
}

sub mergeEnvironments {
  # Merges env2 into env1 and returns the result
  my ($enva,$envb)=(@_);
  my $env=clone($enva);
  foreach (keys %$envb) {
    if (!exists($env->{$_})) {
      $env->{$_}=clone($envb->{$_});
    }
  }
  return $env;
}

sub commandKey {
  my $d=join(' ',map {&quote($_)} @_);
  return $d;
}

sub executeCommand {
  my $in=shift @_;
  &xlog(6,"Executing: ".join(' ',@_));
  my $outputtext="";
  my $errtext="";
  my $pid=open3(\*INPUT, \*OUTPUT, \*ERR,@_);
  print INPUT $in;
  close(INPUT);
  my $done=0;
  do {
    while (<OUTPUT>) {
      $outputtext.=$_;
    }
    while (<ERR>) {
      $errtext.=$_;
    }
    $done=waitpid($pid,WNOHANG);
  } until ($done>0);
  return [ $?, $outputtext, $errtext ];
}

sub existFile {
  my ($f)=@_;
  if ($f =~ /^pseudo:\/\//) {
    return 1;
  }
  return 0 if -d $f;
  return -r $f;
}

sub hashFile {
  my ($f,$env)=@_;
  $env->{'hash'}->{$f}="0";
  if ($f =~ /^pseudo:\/\//) {
    return if (!exists $env->{'pseudofile'}->{$f});
    my $hashing = Digest::MD5->new;
    $hashing->add($env->{'pseudofile'}->{$f});
    $env->{'hash'}->{$f}=$hashing->hexdigest;
    return;
  }
  return "0" if (-d $f);
  return "0" unless (-e $f);
  open FILE,"$f" or return "0";
  my $hashing = Digest::MD5->new;
  $hashing->addfile(*FILE);
  $env->{'hash'}->{$f}=$hashing->hexdigest;
  close FILE;
}


sub xlog {
  $|=1;
  my $level=shift @_;
  print join("\n",@_) unless ($level>$debug);
}


# command = { 'proc' -> \&toto, 'args' -> {} } and returns 0 (to be redone) or 1 (not to be redone)
# command = { 'proc' -> \&genericRunner, 'args' -> {'in'=>$input,'tagline'=>$tagline,'cmdline'=>['some','prog','with','options'] }} and returns 0 (to be redone) or 1 (not to be redone)

=pod

=head1 DESCRIPTION

compile-latex is a program that compiles a TeX file until it reaches a
fixed point. The program assumes that if all the inputs of a program are
the same, then not repeating this program is acceptable; and if any
input of a program changes, then the program is rerun.

compile-latex also manages makeindex. It supports the use of the
C<multind> and C<index> packages for multiple indexes; however, the
automatic mode only uses the C<.idx> to C<.ind> standard index.

compile-latex also manages bibtex.

compile-latex remembers from one compilation to another the index
options it was given. It is not necessary to repeat them (not harmful
either).

compile-latex uses strace to determine the files accessed by a program.

=head1 GIVING OPTIONS

Options may come from:

=over

=item * the command line

=item * previous invocations (if B<--load-all> or B<--load-old> is used)

=item * the file itself in specially formatted comments (if
B<--load-all> or B<--load-input> is used)

=back

Most options are persistent: they will be stored in the hashfile and
remembered on subsequent calls. However, if one category of options is
given in two different sources, the first one takes precedence. For
example, if the command line indicates C<--index-file-suffix adx> and
the last invocation was C<--index-file-suffix idx>, only one index
ending in C<.adx> will be processed (options are not I<merged>).

The B<--load-*> options can be used to select which sources are
considered. Of course, jobnames cannot be read from the hashfile (they
have to be already known at this point).

Comment lines in the input file formatted as follows: one or more
percent char, zero or more spaces, the string C<compile-latex>, one or
more spaces, the string C<"option">, zero or more spaces, the string
C<":"> and one option (without any excess spaces), will be considered as
an option. These options will not be stored for later invocations, since
they are in the file anyway.

=head1 QUOTING

Each option expects a single argument. Some may require spaces to
separate various parts (e.g. B<--index-options>). If one part needs
spaces (a filename, for example), use C<%20> for the space inside the
part. Use C<%25> for a litteral C<%> and C<%3B> for a C<;>. Quoting
should almost never be necessary.

=head1 MAKEFILE

It is difficult to build generic Makefile snippets that satisfy
everyone. The current choice is to build some phony targets: I<all>,
I<do>, I<clean>, I<distclean>, I<depends> and I<depends-as-is>. I<all>,
I<do> and I<depends> will rebuild the targets with the same options that
were used when building the makefile (using B<--load-none>);
I<depends-as-is> will not use B<--load-none>, thus using the currently
selected options. I<do> is phony and will always rebuild all
files. I<all> will rebuild all files that are not up-to-date (it means
older than their dependencies, or not existent). I<depends> will do the
same as I<do>, and rebuild the Makefile (and possibly ignore
files). I<clean> and I<distclean> remove the files (except for the main
output with I<clean>).

To avoid interacting with other targets in the Makefile, all these
targets can be prefixed by some chosen prefix using
B<--makefile-prefix>.

=head1 DEBUG

Debug level varies from 0 (silent, except for results of B<--depends> or
like options) to 7 (very verbose).

The default level is 1 and will print all time consuming operations.

Level 2 will print changed files before launching time consuming operations.

Level 3 will print all operations even skipped ones.

Level 5 will print changed checksums.

=head1 EXAMPLES

    compile-latex file.tex

will compile C<file.tex> as many times as necessary, processing index
and bibtex files as many times as necessary too (sometimes, bibtex index
have to be processed several times because of cross-references).

    compile-latex file.tex --manual --index-file-suffix adx \
    --index-output-suffix and \
    --index-options '-g -t /tmp/log%20indexation' \
    --index-file-suffix odx --index-output-suffix ond --bibtex

will compile C<file.tex> and do some special treatment for auxiliary
programs. First, normal index C<file.idx> will not be processed, as well
as support for C<bibtex> is removed. However, two index files ending in
C<.adx> and C<.odx> (coming from the C<multind> package for example)
will be processed to C<file.and> and the second one to C<file.ond>, the
first being indexed with the C<makeindex> options C<-g> and
C<-t /tmp/log indexation> (remark the space in the filename).

=head1 BUGS

Generation of pictures by other programs is not supposed to be done by
C<compile-latex>, unless the document uses C<write18> to generate the
images (in which case, compile-latex will happily rerun the generation).

Makefile and gitignore options create files not safe to be invoked
outside their own directory. Files with weird names may cause problems
(especially since GNUmake does not support filenames with spaces).

=head1 AUTHOR

Copyright Jean-Christophe Dubacq 2012

=head1 COPYING

This work is licensed under the BSD licence. It is explicitly stated
here that the license does not extend to the data managed by the
  program, in case anyone had doubts.

=cut

